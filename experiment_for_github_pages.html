<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>å›¾åƒå®éªŒï¼šæ ‡æ³¨å¹¶ä¸Šä¼ </title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 30px;
    }
    canvas {
      border: 2px solid #333;
      margin-top: 20px;
      cursor: crosshair;
    }
    #loading {
      font-size: 20px;
      color: #555;
      margin-top: 40px;
    }
    #end-screen {
      color: green;
      font-size: 22px;
      margin-top: 30px;
    }
  </style>
</head>
<body>
  <h1>å®éªŒï¼šç‚¹å‡»è¯†åˆ«å›¾åƒå·®å¼‚</h1>
  <p id="status-msg">æ­£åœ¨åŠ è½½å›¾ç‰‡èµ„æºï¼Œè¯·ç¨å€™...</p>
  <div id="loading">ğŸ”„ åŠ è½½ä¸­ï¼š<span id="progress">0%</span></div>

  <div id="experiment" style="display:none;">
    <canvas id="canvas" width="600"></canvas>
    <p id="msg">å‡†å¤‡ä¸­...</p>
  </div>

  <div id="end-screen" style="display:none;">
    âœ… å®éªŒå®Œæˆï¼Œæ„Ÿè°¢å‚ä¸ï¼
  </div>

  <script>
    const userId = "user_" + Math.random().toString(36).substr(2, 8);
    let imagePairs = [];
    let allPreloadedImages = [];
    let imagesReady = false;
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const msg = document.getElementById('msg');
    const endScreen = document.getElementById('end-screen');
    const loadingEl = document.getElementById('loading');
    const statusEl = document.getElementById('status-msg');
    const progressEl = document.getElementById('progress');
    let current = 0;
    let currentImg = new Image();
    let startTime = 0;

    async function preloadImages() {
      const res = await fetch("img/image_list.json");
      const files = await res.json();
     
      // ä½¿ç”¨ä¸€ä¸ªå¯¹è±¡æ¥å­˜å‚¨å…·æœ‰ç›¸åŒå‰ç¼€çš„å›¾åƒç»„
      const imageGroups = {};
      files.forEach(filename => {
        // æå–æ–‡ä»¶åçš„å‰ç¼€ï¼ˆå³æœ€åä¸€ä¸ªä¸‹åˆ’çº¿ä¹‹å‰çš„éƒ¨åˆ†ï¼Œå¦‚æœæ²¡æœ‰ä¸‹åˆ’çº¿ï¼Œåˆ™æ•´ä¸ªæ–‡ä»¶åä½œä¸ºå‰ç¼€ï¼‰
        const prefix = filename.split('_')[0];
     
        // å¦‚æœè¯¥å‰ç¼€çš„ç»„è¿˜ä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªæ–°ç»„
        if (!imageGroups[prefix]) {
          imageGroups[prefix] = [];
        }
     
        // å°†æ–‡ä»¶åæ·»åŠ åˆ°å¯¹åº”çš„å‰ç¼€ç»„ä¸­
        imageGroups[prefix].push(filename);
      });
     
      // éå†æ¯ä¸ªå›¾åƒç»„ï¼Œé€‰å–å›¾åƒå¯¹
      for (const prefix in imageGroups) {
        const group = imageGroups[prefix];
     
        // æ‰¾å‡ºæ— åç¼€çš„å›¾åƒï¼ˆåå­—æœ€çŸ­çš„ï¼‰
        let baseImage = group.reduce((shortest, current) => {
          return current.split('_').length < shortest.split('_').length ? current : shortest;
        }, group[0]); // æä¾›ä¸€ä¸ªé»˜è®¤å€¼ä»¥é˜²ä¸‡ä¸€
     
        // ä»å‰©ä½™çš„æœ‰åç¼€çš„å›¾åƒä¸­éšæœºé€‰å–ä¸€ä¸ª
        const otherImages = group.filter(filename => filename !== baseImage);
        const randomImage = otherImages[Math.floor(Math.random() * otherImages.length)];
     
        // å°†é€‰å–çš„å›¾åƒå¯¹æ·»åŠ åˆ°å›¾åƒå¯¹æ•°ç»„ä¸­
        imagePairs.push(["img/" + baseImage, "img/" + randomImage]);
      }
     
      // è¾“å‡ºå›¾åƒå¯¹æ•°ç»„ï¼ˆåœ¨å®é™…åº”ç”¨ä¸­ï¼Œä½ å¯èƒ½ä¼šå°†å…¶ç”¨äºåç»­çš„å¤„ç†æˆ–æ˜¾ç¤ºï¼‰
      console.log(imagePairs);
    
      // æ›´æ–°åŠ è½½è¿›åº¦
      let loaded = 0;
      const total = files.length;
      const preloadPromises = files.map(filename => {
        return new Promise(resolve => {
          const img = new Image();
          img.onload = () => {
            loaded++;
            progressEl.textContent = Math.round((loaded / total) * 100) + "%";
            resolve();
          };
          img.onerror = resolve;
          img.src = "img/" + filename;
          allPreloadedImages.push(img);
        });
      });
    
      await Promise.all(preloadPromises);
    
      // å›¾ç‰‡åŠ è½½å®Œæˆï¼Œæ›´æ–°ç•Œé¢
      imagesReady = true;
      loadingEl.style.display = "none";
      statusEl.textContent = "å›¾ç‰‡åŠ è½½å®Œæˆï¼Œç‚¹å‡»ä»»æ„ä½ç½®å¼€å§‹";
      statusEl.style.cursor = "pointer"; // æ·»åŠ é¼ æ ‡æŒ‡é’ˆæ ·å¼ï¼Œæç¤ºç”¨æˆ·å¯ä»¥ç‚¹å‡»
    }

    preloadImages();

    // ä¿®æ”¹ä¸ºç‚¹å‡»ä»»æ„ä½ç½®å¼€å§‹å®éªŒ
    document.addEventListener('click', function handleClick(e) {
      if (imagesReady) {
        document.removeEventListener('click', handleClick);
        statusEl.style.display = 'none';
        document.getElementById('experiment').style.display = 'block';
        nextImage();
      }
    });

    function nextImage() {
      if (current >= imagePairs.length) {
        document.getElementById('experiment').style.display = 'none';
        endScreen.style.display = 'block';
        return;
      }

      const [imgA, imgB] = imagePairs[current];
      currentImg = new Image();
      currentImg.onload = () => {
        // è·å–åŸå§‹å›¾ç‰‡çš„å®½é«˜
        const originalWidth = currentImg.width;
        const originalHeight = currentImg.height;

        // è®¾ç½®ç»Ÿä¸€çš„é«˜åº¦
        const unifiedHeight = 1000;
        const scale = unifiedHeight / originalHeight;
        const unifiedWidth = originalWidth * scale;

        // è°ƒæ•´ç”»å¸ƒå¤§å°
        canvas.width = unifiedWidth;
        canvas.height = unifiedHeight;

        // ç»˜åˆ¶å›¾ç‰‡
        ctx.drawImage(currentImg, 0, 0, unifiedWidth, unifiedHeight);
        msg.innerText = `ç¬¬ ${current + 1} å¯¹å›¾ - ç¬¬ä¸€å¼ `;

        setTimeout(() => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          msg.innerText = "åˆ‡æ¢ä¸­...";
          setTimeout(() => {
            currentImg = new Image();
            currentImg.onload = () => {
              ctx.drawImage(currentImg, 0, 0, unifiedWidth, unifiedHeight);
              msg.innerText = "ç‚¹å‡»ä½ çœ‹åˆ°å˜åŒ–çš„åŒºåŸŸ";
              startTime = performance.now();
              canvas.onclick = recordClick;
            };
            currentImg.onerror = () => {
              msg.innerText = "âŒ å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥å›¾ç‰‡è·¯å¾„ã€‚";
              console.error("å›¾ç‰‡åŠ è½½å¤±è´¥ï¼š", imgB);
            };
            currentImg.src = imgB;
          }, 200);
        }, 1000);
      };
      currentImg.src = imgA;
    }

    function recordClick(e) {
      const rect = canvas.getBoundingClientRect();
      const x = Math.round(e.clientX - rect.left);
      const y = Math.round(e.clientY - rect.top);
      const elapsed = Math.round(performance.now() - startTime);

      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(x, y, 10, 0, Math.PI * 2);
      ctx.fill();

      const imageData = canvas.toDataURL("image/png");
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
      const pairIndex = current + 1;
      const fileName = `${userId}_pair${pairIndex}_${timestamp}.png`;

      const payload = {
        imageData,
        fileName,
        userId,
        experimentId: pairIndex,
        pairIndex,
        timestamp: new Date().toLocaleString(),
        clickedX: x,
        clickedY: y,
        timeMs: elapsed,
        imageA: imagePairs[current][0],
        imageB: imagePairs[current][1]
      };

      fetch("https://script.google.com/macros/s/AKfycby88M0KVbC5OeLttT0KofbQBNNgrsHEcRRUHeauhzZedR_BmbquifV6aUM-sM3GuhDs/exec", {
        method: "POST",
        body: JSON.stringify(payload)
      }).catch((err) => {
        console.warn("ä¸Šä¼ å¤±è´¥ï¼ˆé™é»˜å¤„ç†ï¼‰", err);
      });

      canvas.onclick = null;
      current++;
      setTimeout(nextImage, 500);
    }
  </script>
</body>
</html>
